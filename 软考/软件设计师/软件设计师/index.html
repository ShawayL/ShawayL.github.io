<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>软件设计师 - shaway</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="shaway"><meta name="msapplication-TileImage" content="/images/logo/sasuke.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="shaway"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="316x316" href="/images/logo/sasuke.png"><meta name="description" content="软件设计师"><meta property="og:type" content="blog"><meta property="og:title" content="软件设计师"><meta property="og:url" content="https://shawayl.github.io/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"><meta property="og:site_name" content="shaway"><meta property="og:description" content="软件设计师"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://shawayl.github.io/images/cover/640%20(1).png"><meta property="article:published_time" content="2025-04-18T06:14:00.000Z"><meta property="article:modified_time" content="2025-04-18T06:14:00.000Z"><meta property="article:author" content="shaway"><meta property="article:tag" content="软考"><meta property="article:tag" content="软件设计师"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://shawayl.github.io/images/cover/640%20(1).png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://shawayl.github.io/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"},"headline":"软件设计师","image":["https://shawayl.github.io/images/cover/640%20(1).png"],"datePublished":"2025-04-18T06:14:00.000Z","dateModified":"2025-04-18T06:14:00.000Z","author":{"@type":"Person","name":"shaway"},"publisher":{"@type":"Organization","name":"shaway","logo":{"@type":"ImageObject","url":"https://shawayl.github.io/images/logo/sasuke.png"}},"description":"软件设计师"}</script><link rel="canonical" href="https://shawayl.github.io/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"><link rel="icon" href="/images/logo/sasuke.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo/sasuke.png" alt="shaway" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="repositories" href="https://github.com/ShawayL/HexoBlog"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/cover/640%20(1).png" alt="软件设计师"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-18T06:14:00.000Z" title="4/18/2025, 6:14:00 AM">2025-04-18</time>发表</span><span class="level-item"><time dateTime="2025-04-18T06:14:00.000Z" title="4/18/2025, 6:14:00 AM">2025-04-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%BD%AF%E8%80%83/">软考</a><span> / </span><a class="link-muted" href="/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a></span><span class="level-item">1 小时读完 (大约9972个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">软件设计师</h1><div class="content"><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86">计算机系统知识</a><ul>
<li><a href="#cpu%E7%9A%84%E7%BB%84%E6%88%90">CPU的组成</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F">存储系统</a></li>
<li><a href="#%E6%A0%A1%E9%AA%8C%E7%A0%81">校验码</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">输入输出</a></li>
</ul>
</li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">程序设计语言基础知识</a><ul>
<li><a href="#%E5%90%8E%E7%BC%80%E5%BC%8F">后缀式</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97">数据结构与数据运算</a><ul>
<li><a href="#%E6%A0%91">树</a><ul>
<li><a href="#%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">树转二叉树</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE">图</a><ul>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E6%89%BE">查找</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">软件工程基础知识</a><ul>
<li><a href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B">软件过程模型</a></li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BB%B4%E6%8A%A4%E6%96%B9%E9%9D%A2">软件的四个维护方面</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95">结构化开发方法</a><ul>
<li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">结构化分析方法</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">结构化设计方法</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF">面向对象技术</a><ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B5%8B%E8%AF%95">面向对象测试</a></li>
<li><a href="#uml%E7%9A%84%E5%85%B3%E7%B3%BB">UML的关系</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">设计原则</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">创建型设计模式</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">结构型设计模式</a></li>
<li><a href="#%E8%A1%8C%E4%B8%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">行为设计模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90">算法设计与分析</a><ul>
<li><a href="#%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95">动态规划法</a></li>
<li><a href="#%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法</a></li>
<li><a href="#%E5%9B%9E%E6%BA%AF%E6%B3%95">回溯法</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80">数据库技术基础</a><ul>
<li><a href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96">关系数据库的规范化</a><ul>
<li><a href="#armstrong%E5%85%AC%E7%90%86">Armstrong公理</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C">数据库操作</a></li>
<li><a href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96-1">关系数据库的规范化</a></li>
<li><a href="#%E6%9D%83%E9%99%90">权限</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">网络与信息安全基础知识</a><ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">网络体系结构</a></li>
</ul>
</li>
<li><a href="#%E6%9C%AA%E5%88%86%E7%B1%BB">未分类</a><ul>
<li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">关键路径</a></li>
<li><a href="#%E6%B2%9F%E9%80%9A%E8%B7%AF%E5%BE%84">沟通路径</a></li>
<li><a href="#%E6%A0%91%E7%9A%84%E5%BA%A6%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E8%BE%B9%E6%95%B0">树的度、叶子节点数、边数</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E5%8A%9F%E8%83%BD%E5%92%8C%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3">常见协议功能和默认端口</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95">常见算法</a></li>
<li><a href="#%E5%8F%AF%E9%9D%A0%E5%BA%A6">可靠度</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">数据库安全相关术语</a></li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">软件测试方法</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE">程序流程图</a><ul>
<li><a href="#mccabe%E5%A4%8D%E6%9D%82%E5%BA%A6">McCabe复杂度</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF">流水线技术</a></li>
<li><a href="#uml%E5%BA%8F%E5%88%97%E5%9B%BE">UML序列图</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B4%A2%E5%BC%95">文件系统索引</a></li>
<li><a href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">页式存储管理系统</a></li>
</ul>
</li>
</ul>
<h1 id="计算机系统知识"><a href="#计算机系统知识" class="headerlink" title="计算机系统知识"></a>计算机系统知识</h1><h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><p>CPU主要由<strong>运算器</strong>、<strong>控制器</strong>、<strong>寄存器组</strong>和<strong>内部总线</strong>等部件组成</p>
<ul>
<li><strong>运算器</strong><ul>
<li><strong>算术逻辑单元(ALU)</strong>:负责处理数据，实现对数据的算术运算和逻辑运算。</li>
<li><strong>累加寄存器(AC)</strong>:也称为累加器，是一个通用寄存器，功能是当运算器的算术逻辑单元执行算术运算或逻辑运算时，为ALU提供一个工作区。</li>
<li><strong>数据缓冲寄存器(DR)</strong>:在对内存储器进行读&#x2F;写操作时，用DR暂时存放由内存储器读&#x2F;写的一条指令或一个数据字，将不同时间段内的读&#x2F;写数据隔离。主要作用是作为CPU和内存、外部设备之间数据传送的中转站;作为CPU和内存、外围设备之间在操作速度上的缓冲;在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数据寄存器。</li>
<li><strong>状态条件寄存器(PSW)</strong>:由算数指令和逻辑指令运行或测试的结果建立的各种条件码内容，主要分为状态标志和控制标志</li>
</ul>
</li>
<li><strong>控制器</strong><ul>
<li><strong>指令寄存器（IR）</strong>:当CPU执行一条指令时，先把它从内存储器取到缓冲寄存器中，再送入IR暂存，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。</li>
<li><strong>程序计数器（PC）</strong>:<strong>存储下一条要执行的指令的地址</strong>，具有寄存信息和计数两种功能，又称为指令计数器。程序的执行分为两种情况，一是顺序执行，二是转移执行。</li>
<li><strong>地址寄存器（AR）</strong>:保存当前CPU所访问的内存单元的地址。</li>
<li><strong>指令译码器（ID）</strong>:指令分为操作码和地址码两个部分，为了执行任何给定的命令，必须对操作码进行分析，以便识别所有完成的操作。</li>
</ul>
</li>
<li><strong>寄存器组</strong><br>寄存器组分为专用寄存器和通用寄存器。运算器和控制器中的寄存器是专用寄存器，其作用是固定的。通用寄存器的用途广泛，并且由程序员规定其用途，其数目因处理器的不同有所差异。</li>
</ul>
<p><strong>指令寄存器</strong>（IR）用来保存当前正在执行的指令。当执行一条指令时，先把它从内存取到<strong>数据寄存器</strong>（DR）中，然后再传送至<strong>IR</strong>。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作，<strong>指令译码器</strong>（ID）就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。 </p>
<p><strong>地址寄存器</strong>（AR）用来保存当前CPU所访问的内存单元的地址。由于内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读&#x2F;写操作完成为止。 </p>
<p>为了保证程序指令能够连续地执行下去，CPU 必须具有某些手段来确定下一条指令的地址，<strong>程序计数器</strong>正起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入<strong>程序计数器</strong>（PC），因此PC的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令，PC就增加一个量，这个量等于指令所含的字节数，以便使其总保持将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。</p>
<h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><ul>
<li><strong>CPU</strong>对应的存储类别:<strong>寄存器</strong></li>
<li><strong>Cache</strong>对应的存储类别:<strong>缓存</strong></li>
<li><strong>DRAM</strong>对应的存储类别:<strong>主存</strong></li>
<li><strong>硬盘、光盘</strong>对应的存储类别:<strong>辅存</strong></li>
</ul>
<h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><ul>
<li><p><strong>奇偶校验码</strong><br> 奇偶校验码（Parity Code）是一种简单有效的校验方法。这种方法通过在编码中增加一位校验位，使编码中1的个数为奇数（奇校验）或偶数（偶校验），从而使码距变为2。</p>
</li>
<li><p><strong>海明码</strong><br> 海明码（Hamming Code）是利用奇偶性来查错和纠错的校验方法。</p>
<ol>
<li><p>海明码确定校验位公式：<br>$2^k-1 \geq n+k$<br>$k$：检验位<br>$n$：数据位<br>$n+k$：数据总位数</p>
</li>
<li><p>校验码在二进制串中的位置为2的整数幂。剩下的位置为数据。如下表所示（以1010110这个二进制数为例）：</p>
<div style='overflow-x:auto;'>

<table>
<thead>
<tr>
<th>位置</th>
<th>0001</th>
<th>0010</th>
<th>0011</th>
<th>0100</th>
<th>0101</th>
<th>0110</th>
<th>0111</th>
<th>1000</th>
<th>1001</th>
<th>1010</th>
<th>1011</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>x1</td>
<td>x2</td>
<td>1</td>
<td>x3</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x4</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
</div>

<p>为了求出x2,要使所有位置的第二位是1的数据（即形如*<em>1</em>的位置的数据）的异或值为0（不同为1相同为0，结果就是有偶数个1）。即<code>x2^1^1^0^1^0 = 0</code>。因此x2 &#x3D; 1。<br>同理可得x1 &#x3D; 0, x3 &#x3D; 1, x4 &#x3D; 0。</p>
<div style='overflow-x:auto;'>

<table>
<thead>
<tr>
<th>位置</th>
<th>0001</th>
<th>0010</th>
<th>0011</th>
<th>0100</th>
<th>0101</th>
<th>0110</th>
<th>0111</th>
<th>1000</th>
<th>1001</th>
<th>1010</th>
<th>1011</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
</div></li>
</ol>
</li>
<li><p><strong>循环冗余校验码</strong><br> 循环冗余校验码（Cyclic Redundancy Check，CRC）由两部分组成，左边为信息码（数据），右边为校验码。</p>
</li>
</ul>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul>
<li>程序控制(查询)方式：分为无条件传送和程序查询方式。方法简单，硬件开销小，但IO能力不 高，严重影响CPU的利用率。</li>
<li>程序中断方式：与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度。</li>
<li>DMA方式：DMA方式是为了在主存与外设之间实现高速、批量数据交换而设置的。DMA方式比程序控制方式与中断方式都高效。</li>
</ul>
<h1 id="程序设计语言基础知识"><a href="#程序设计语言基础知识" class="headerlink" title="程序设计语言基础知识"></a>程序设计语言基础知识</h1><h2 id="后缀式"><a href="#后缀式" class="headerlink" title="后缀式"></a>后缀式</h2><p>解决该类问题的方法是将算术表达式构造成一棵二叉树，然后对二叉树进行后序遍历得到后缀式。</p>
<p><code>a+(b-c)*d</code>的后缀式是<code>abc-d*+</code></p>
<p><code>b*(a+c)-d</code>的后缀式是<code>bac+*d-</code></p>
<h1 id="数据结构与数据运算"><a href="#数据结构与数据运算" class="headerlink" title="数据结构与数据运算"></a>数据结构与数据运算</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li><strong>满二叉树</strong>：如果一个二叉树的层数为K，结点总数为$2^k-1$个，则它就是满二叉树。 </li>
<li><strong>完全二叉树</strong>：在一个深度为h的完全二叉树中，除第h层外（最后一层），其他各层都是满的。第h层所有的结点都必须从左到右依次放置，不能留空。<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-6.png" class="" title="alt text"></li>
<li><strong>最优二叉树</strong>：最优二叉树（哈夫曼树）的求法：给出一组权值，将其中两个最小的权值作为叶子节点，其和作为父节点，组成二叉树，而后删除这两个叶子节点权值，并将父节点的值添加到该组权值中。重复进行上述步骤，直至所有权值都被使用完。<strong>哈夫曼树节点的度只能是0度或2度</strong>。</li>
</ul>
<h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-10.png" class="" title="alt text">

<p>在兄弟结点之间添加连线</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-11.png" class="" title="alt text">

<p>去除<strong>非长子外</strong>的连线</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-12.png" class="" title="alt text">

<p><strong>父子</strong>连线变为<strong>左子树</strong>，<strong>兄弟</strong>连线变为<strong>右子树</strong></p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-13.png" class="" title="alt text">

<p>二叉树转树将上述操作反过来即可</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>有向图、无向图以及其邻接矩阵</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-4.png" class="" title="alt text">

<p>邻接表：邻接表表示法是指为图中的每一个顶点建立一个单链表。</p>
<p>有向图及其邻接表如下图所示</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-5.png" class="" title="alt text">

<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul>
<li>最小生成树——<strong>克鲁斯卡尔算法</strong>：这个算法是从边出发的，因为本质是选取权值最小的n-1 条边，因此，就将边按权值大小排序，依次选取权值最小的边，直至囊括所有节点，要注意，每次选边后要检查不能形成环路。克鲁斯卡尔算法的时间复杂度为O（eloge），与图中的顶点数无关，因此该算法适合于求边稀疏的网的最小生成树。</li>
<li>最小生成树——<strong>普里姆算法</strong>：从任意顶点出发，找出与其邻接的边权值最小的，此时此边的另外一个顶点自动加入树集合中，而后再从这这个树集合的所有顶点中找出与其邻接的边权值最小的，同样此边的另外一个顶点加入树集合中，依次递归，直至图中所有顶点都加入树集合中，此时此树就是该图的最小生成树。普里姆算法的时间复杂度为O（n^2），与图中的边数无关，因此该算法适合于求边稠密的网的最小生成树：</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ol>
<li>顺序查找<br>将待查的元素从头到尾与表中元素进行比较，如果存在，则返回成功；否则，查找失败。此方法效率不高。顺序查找的平均查找长度为$(n+1)&#x2F;2$。</li>
<li>二分查找<br>  二分查找的前提是元素有序（一般是升序），基本思路是拿中间元素$A[m]$与要查找的元素$x$进行比较，如果相等，则表示找到；如果$A[m]$比$x$大，那么要找的元素一定在$A[m]$前边（左边）；如果$A[m]$比$x$小，那么要找的元素一定在$A[m]$后边（右边）。每进行一次查找，数组规模减半。反复将子数组规模减半或使当前子数组为空，直到发现要查找的元素。<br>  长度为$n$的有序数组二分查找的最大查找次数为$\lceil \log_2 n \rceil$（向上取整）。</li>
<li>哈希查找</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>详表</p>
<div style='overflow-x:auto;'>

<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均</th>
<th>最好</th>
<th>最坏</th>
<th>空间</th>
<th>排序方式</th>
<th>稳定性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>In-place</td>
<td>稳定</td>
<td>左侧已排序，右侧未排序，在插入第$i$个记录时，$R_1$,$R_2$,…,$R_{i-1}$均已排好序，这时将第$i$&#96;个记录依次与$R_{i-1}$,…,$R_2$,$R_1$进行比较，找到合适的位置插入，插入位置及之后的记录依次向后移动</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>In-place</td>
<td>稳定</td>
<td>通过相邻元素（$i$ 与 $i-1$）之间的比较和交换，将排序码较小的元素逐渐从底层移向顶层。</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>In-place</td>
<td>不稳定</td>
<td>左侧已排序，右侧未排序，在右侧未排序序列中选择一个最小&#x2F;最大元素与右侧未排序序列中最左边元素交换</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n^{1.3})$</td>
<td>$O(n^{1.3})$</td>
<td>$O(n^{1.3})$</td>
<td>$O(1)$</td>
<td>In-place</td>
<td>不稳定</td>
<td>先将整个序列分为若干子列（由某个增量控制），插入排序子列，减少增量，直至减少为1</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlog_n)$</td>
<td>$O(nlog_n)$</td>
<td>$O(n^2)$</td>
<td>$O(log_n)$</td>
<td>In-place</td>
<td>不稳定</td>
<td>使用分而治之思想，选中一个基数（base），比它大的放在右，比它小的放在左，分别在递归排序左右两个序列</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlog_n)$</td>
<td>$O(nlog_n)$</td>
<td>$O(nlog_n)$</td>
<td>$O(1)$</td>
<td>In-place</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlog_n)$</td>
<td>$O(nlog_n)$</td>
<td>$O(nlog_n)$</td>
<td>$O(n)$</td>
<td>Out-place</td>
<td>稳定</td>
<td></td>
</tr>
</tbody></table>
</div>

<p>简图</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-14.png" class="" title="alt text">

<p>排序算法的稳定性是指在排序过程中，相等元素的相对顺序是否保持不变。如果一个排序算法在排序后，所有相等元素的相对顺序与排序前相同，那么这个排序算法就是稳定的；否则就是不稳定的。</p>
<h1 id="软件工程基础知识"><a href="#软件工程基础知识" class="headerlink" title="软件工程基础知识"></a>软件工程基础知识</h1><h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><ol>
<li><strong>瀑布模型</strong>：只适用于<strong>需求明确</strong>或者<strong>二次开发</strong>（需求稳定），当需求不明确时，最终开发的项目会错误，有很大的缺陷。<ul>
<li>瀑布模型的优点：容易理解、成本低、强调开发的阶段性早期计划及需求调查和产品测试。</li>
<li>瀑布模型的缺点：<strong>缺乏灵活性</strong>，客户必须要准确地表达他们的需要；在开始的两个或三个阶段中，很难评估真正的进度状态；项目快结束时，出现大量的集成与测试工作；项目结束之前，不能演示系统的能力。</li>
</ul>
</li>
<li><strong>V模型</strong>：强调测试贯穿项目始终，而不是集中在测试阶段。是一种测试的开发模型。是瀑布模型的一个变体。</li>
<li><strong>增量模型</strong>：可以有<strong>多个可用版本</strong>的发布，核心功能往往最先完成，在此基础上，每轮迭代会有新的增量发布， 核心功能可以得到充分测试。强调每一个增量均发布一个可操作的产品。<ul>
<li>增量模型的优点：可交付的第一个版本所需要的成本和时间很少，开发由增量表示的小系统所承担的风险不大，由于很快发布了第一个版本，因此可减少用户需求的变更。同时，它也具有瀑布模型所有的优点。</li>
<li>增量模型的缺点：若没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；若需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发或重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。</li>
</ul>
</li>
<li><strong>演化模型（原型模型、螺旋模型）</strong>：典型的演化模型有原型模型和螺旋模型。<ul>
<li><strong>原型模型</strong>：典型的原型开发方法模型。适用于需求不明确的场景，可以帮助用户明确需求。</li>
<li><strong>螺旋模型</strong>：<strong>结合了瀑布模型和演化模型的优点</strong>，但是增加了<strong>风险分析</strong>，针对<strong>需求不明确</strong>的项目，这也是其最大的特点。<strong>适合大型项目开发</strong>。</li>
</ul>
</li>
<li><strong>喷泉模型</strong>：<strong>以用户需求为动力</strong>，<strong>以对象为驱动</strong>，适合于<strong>面向对象</strong>的开发方法</li>
<li><strong>基于构件的开发模型</strong>：基于构件的开发模型是指利用预先包装的构件来构造应用系统。构件可以是组织内部开发的构件，也可以是商品化成品（COTS）软件构件。一种基于构件的开发模型包括领域工程和应用系统工程。</li>
<li><strong>形式化方法模型</strong>：形式化方法是建立在严格数学基础上的一种软件开发方法，主要活动是生成计算机软件形式化的数学规格说明。</li>
<li><strong>统一过程模型</strong>：统一过程（UP）模型是一种“用例和风险驱动，以架构为中心，迭代并增量”的开发过程，由UML方法和工具支持。<ul>
<li>统一过程的典型代表是RUP，RUP是UP的商业扩展，完全兼容UP，比UP更完整、更详细。</li>
<li>敏捷方法的总体目标是通过“尽可能早地、持续地对有价值的软件进行交付”使客户满意。敏捷过程的典型方法有很多，每一种方法基于一套原则，这些原则实现了敏捷方法所宣称的理念，即敏捷宣言。</li>
<li>常用的方法：极限编程（XP）、水晶法（Crystal）、并列争球法（Scrum）、自适应软件开发（ASD）、敏捷统一过程（AUP）。</li>
</ul>
</li>
</ol>
<h2 id="软件的四个维护方面"><a href="#软件的四个维护方面" class="headerlink" title="软件的四个维护方面"></a>软件的四个维护方面</h2><ul>
<li><strong>改正性维护</strong>是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</li>
<li><strong>适应性维护</strong>是指使应用软件适应信息技术变化和管理需求变化而进行的修改。</li>
<li><strong>完善性维护</strong>是指为了扩充功能和改善性能而进行的修改，主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</li>
<li><strong>预防性维护</strong>是指为了改进应用软件的可靠性和可维护性，为了适应未来的软件、硬件环境的变化，应主动增加预防性的新功能，以使应用系统可以适应各类变化而不被淘汰。</li>
</ul>
<h1 id="结构化开发方法"><a href="#结构化开发方法" class="headerlink" title="结构化开发方法"></a>结构化开发方法</h1><h2 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h2><p>结构化分析（SA）概述<br>抽象（自底向上）、分解（自顶向下）</p>
<p>数据流图（DFD）的基本要素：外部实体、加工、数据存储、数据流</p>
<p>数据流图的常见错误</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-3.png" class="" title="alt text">

<p>数据流图的审查 </p>
<ol>
<li>一致性：父图与子图平衡、数据守恒、具备数据存储、输出不能与输入同名。 </li>
<li>完整性：奇迹（无入有出）、黑洞（有入无出）、灰洞（无法出）。</li>
</ol>
<h2 id="结构化设计方法"><a href="#结构化设计方法" class="headerlink" title="结构化设计方法"></a>结构化设计方法</h2><ol>
<li><strong>模块结构图</strong>是结构化设计的工具，由<strong>模块</strong>、<strong>调用</strong>、<strong>数据</strong>、<strong>控制</strong>和<strong>转接</strong>五种基本符号组成。</li>
<li>结构化设计主要包括：<strong>体系结构设计</strong>、<strong>数据设计</strong>、<strong>接口设计</strong>、<strong>过程设计</strong>。</li>
</ol>
<h1 id="面向对象技术"><a href="#面向对象技术" class="headerlink" title="面向对象技术"></a>面向对象技术</h1><h2 id="面向对象测试"><a href="#面向对象测试" class="headerlink" title="面向对象测试"></a>面向对象测试</h2><p>面向对象测试分为四个层次执行:</p>
<ul>
<li><strong>算法层</strong>:测试<strong>类中定义的每个方法</strong>，基本相当于传统软件测试的单元测试。</li>
<li><strong>类层</strong>:测试封装在<strong>同一个类中的所有方法与属性之间的相互作用</strong>。可以认为是面向对象测试中特有的模块测试。</li>
<li><strong>模板层</strong>:测试一组协调工作的<strong>类之间的相互作用</strong>。大体上相当于传统软件测试中的集成测试。</li>
<li><strong>系统层</strong>:把各个子系统组装成完整的面向对象软件系统，在组装过程中同时进行测试。</li>
</ul>
<h2 id="UML的关系"><a href="#UML的关系" class="headerlink" title="UML的关系"></a>UML的关系</h2><p>UML中有四种关系：<strong>依赖</strong>、<strong>关联</strong>、<strong>泛化</strong>和<strong>实现</strong></p>
<ul>
<li><strong>依赖关系</strong>：一个事物发生变化影响另一个事物。</li>
<li><strong>关联关系</strong>：描述了一组链，链是对象之间的连接。</li>
<li><strong>泛化关系</strong>：特殊&#x2F;一般关系。</li>
<li><strong>实现关系</strong>：接口与类之间的关系。</li>
<li><strong>聚合关系</strong>：整体与部分生命周期不同。</li>
<li><strong>组合关系</strong>：整体与部分生命周期相同。</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li><strong>稳定抽象原则</strong>:此原则强调的是包的抽象程度与其稳定程度一致。</li>
<li><strong>稳定依赖原则</strong>:此原则要求包之间的依赖关系都应该是稳定方向依赖的，即包要依赖的包要比自己更具有稳定性。</li>
<li><strong>依赖倒置原则</strong>:此原则强调的是程序应该依赖于抽象接口，而不是具体的实现，从而降低客户与实现模块间的耦合。</li>
<li><strong>无环依赖</strong>:这个原则明确指出，在组件的依赖关系在图中不允许存在环。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h3><ul>
<li><p><strong>抽象工厂（Abstract Factory）</strong><br>提供一个接口，用于创建相关或依赖对象的家族，而无需明确指定具体类。<br><strong>应用场景</strong>：需要创建一组相关或相互依赖的对象时，例如跨平台 UI 工具包。</p>
</li>
<li><p><strong>生成器（Builder）</strong><br>将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>应用场景</strong>：需要创建复杂对象，并且需要灵活地控制其构建过程时，例如构建器模式用于生成复杂的文档或报表。</p>
</li>
<li><p><strong>工厂方法（Factory Method）</strong><br>定义一个用于创建对象的接口，让子类决定实例化哪一个类。<br><strong>应用场景</strong>：当一个类无法预知它需要创建的对象时，例如日志记录器可以根据配置选择不同的日志记录方式。</p>
</li>
<li><p><strong>原型（Prototype）</strong><br>通过复制现有对象来创建新对象，而不是通过实例化类。<br><strong>应用场景</strong>：需要大量相似对象时，例如克隆复杂对象以提高性能。</p>
</li>
<li><p><strong>单例（Singleton）</strong><br>确保一个类只有一个实例，并提供一个全局访问点。<br><strong>应用场景</strong>：需要全局唯一的对象时，例如配置管理器、线程池或数据库连接池。</p>
</li>
</ul>
<h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><ul>
<li><p><strong>适配器（Adapter）</strong><br>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。<br><strong>应用场景</strong>：系统需要使用现有的类，但其接口不符合需求时，例如将旧系统的接口适配到新系统。</p>
</li>
<li><p><strong>桥接（Bridge）</strong><br>将抽象部分与实现部分分离，使它们可以独立变化。<br><strong>应用场景</strong>：需要在抽象和实现之间增加更多的灵活性时，例如跨平台图形界面工具。</p>
</li>
<li><p><strong>组合（Composite）</strong><br>将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。<br><strong>应用场景</strong>：需要表示对象的部分-整体层次结构时，例如文件系统中的文件和文件夹。</p>
</li>
<li><p><strong>装饰（Decorator）</strong><br>动态地给对象添加一些额外的职责，而不影响其他对象的功能。<br><strong>应用场景</strong>：需要动态地扩展对象的功能时，例如为图形界面组件添加滚动条或边框。</p>
</li>
<li><p><strong>外观（Facade）</strong><br>为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。<br><strong>应用场景</strong>：需要为复杂的子系统提供一个简单的接口时，例如为多模块系统提供统一的入口。</p>
</li>
<li><p><strong>享元（Flyweight）</strong><br>运用共享技术有效地支持大量细粒度对象的复用，减少内存消耗。<br><strong>应用场景</strong>：需要大量相似对象时，例如字符处理系统中的字符对象。</p>
</li>
<li><p><strong>代理（Proxy）</strong><br>为其他对象提供一种代理以控制对这个对象的访问。<br><strong>应用场景</strong>：需要控制对对象的访问时，例如远程代理、虚拟代理或保护代理。</p>
</li>
</ul>
<h3 id="行为设计模式"><a href="#行为设计模式" class="headerlink" title="行为设计模式"></a>行为设计模式</h3><ul>
<li><p><strong>责任链（Chain of Responsibility）</strong><br>允许多个对象有机会处理请求，将这些对象连成一条链，沿着链传递请求，直到某个对象处理它为止。<br><strong>应用场景</strong>：日志处理、权限校验等。</p>
</li>
<li><p><strong>命令（Command）</strong><br>将请求封装为对象，使得可以用不同的请求、队列或日志来参数化对象。支持撤销和重做操作。<br><strong>应用场景</strong>：事务操作、按钮点击事件处理。</p>
</li>
<li><p><strong>解释器（Interpreter）</strong><br>定义一种语言的文法表示，并提供一个解释器来解释语言中的句子。<br><strong>应用场景</strong>：编译器、正则表达式解析器。</p>
</li>
<li><p><strong>迭代器（Iterator）</strong><br>提供一种方法顺序访问集合对象中的元素，而不暴露其内部表示。<br><strong>应用场景</strong>：遍历集合（如数组、链表）。</p>
</li>
<li><p><strong>中介者（Mediator）</strong><br>用一个中介对象封装一组对象之间的交互，使对象之间不需要直接引用，降低耦合性。<br><strong>应用场景</strong>：聊天室、MVC 中的控制器。</p>
</li>
<li><p><strong>备忘录（Memento）</strong><br>在不破坏封装的前提下，捕获对象的内部状态，并在以后恢复它。<br><strong>应用场景</strong>：撤销功能、游戏存档。</p>
</li>
<li><p><strong>观察者（Observer）</strong><br>定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知并自动更新。<br><strong>应用场景</strong>：事件监听、发布-订阅模式。</p>
</li>
<li><p><strong>状态（State）</strong><br>允许对象在内部状态改变时改变其行为，看起来像是改变了其类。<br><strong>应用场景</strong>：状态机、订单状态管理。</p>
</li>
<li><p><strong>策略（Strategy）</strong><br>定义一系列算法，将每个算法封装起来，并使它们可以互换。<br><strong>应用场景</strong>：支付方式选择、排序算法。</p>
</li>
<li><p><strong>模板方法（Template Method）</strong><br>定义一个操作的骨架，将一些步骤延迟到子类中。子类可以不改变骨架的情况下重新定义某些步骤。<br><strong>应用场景</strong>：算法框架、代码生成器。</p>
</li>
<li><p><strong>访问者（Visitor）</strong><br>提供一种操作一组对象的方法，使得可以在不改变这些对象的类的前提下定义新的操作。<br><strong>应用场景</strong>：编译器语法树操作、对象结构遍历。</p>
</li>
</ul>
<h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>基本思想</p>
<p>使用<strong>递归技术</strong>，把一个问题<strong>拆分</strong>成多个小规模的相同子问题。</p>
<p>实例：归并排序、快速排序、二分搜索</p>
<h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><p>基本思想</p>
<ol>
<li>找出最优解的性质，并刻画其结构特征。</li>
<li>递归定义最优解的值。</li>
<li>自底向上算出最优解。</li>
<li>构造最优解。</li>
</ol>
<p>实例：矩阵乘法、背包问题、LCS最长公共子序列</p>
<h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><p>一般用于求满意解，特殊情况可求最优解(部分背包)</p>
<p>实例：背包问题(如装箱)、多机调度、找零钱问题</p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>系统地搜索一个问题的所有解或任一解。有试探和回退的过程。</p>
<p>实例：N皇后问题、迷宫、背包 问题</p>
<h1 id="数据库技术基础"><a href="#数据库技术基础" class="headerlink" title="数据库技术基础"></a>数据库技术基础</h1><h2 id="关系数据库的规范化"><a href="#关系数据库的规范化" class="headerlink" title="关系数据库的规范化"></a>关系数据库的规范化</h2><h4 id="Armstrong公理"><a href="#Armstrong公理" class="headerlink" title="Armstrong公理"></a>Armstrong公理</h4><p>Armstrong公理系统设关系模式<code>R&lt;U,F&gt;</code>，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则：</p>
<p>A1<strong>自反律</strong>：若<code>Y⊆X⊆U</code>，则<code>X→Y</code>为F所蕴含；<br>A2<strong>增广律</strong>：若<code>X→Y</code>为F所蕴含，且<code>Z⊆U</code>，则<code>XZ→YZ</code>为F所蕴含；<br>A3<strong>传递律</strong>：若<code>X→Y</code>，<code>Y→Z</code>为F所蕴含，则<code>X→Z</code>为F所蕴含。</p>
<p>根据上面三条推理规则，又可推出下面三条推理规则：</p>
<p><strong>合并</strong>规则：若<code>X→Y</code>，<code>X→Z</code>，则<code>X→YZ</code>为F所蕴含。<br><strong>分解</strong>规则：若<code>X→Y</code>，<code>Z⊆Y</code>，则<code>X→Z</code>为F所蕴含。<br><strong>伪传递</strong>规则：若<code>X→Y</code>，<code>WY→Z</code>，则<code>XW→Z</code>为F所蕴含。</p>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>基本关系运算</p>
<ol>
<li>笛卡尔积：相乘。 </li>
<li>投影π：选列。 </li>
<li>选择σ：选行。</li>
<li>自然连接~：结果的属性列数是二者之和减去重复列数，结果元组是同名属性列取值相等的元组。</li>
</ol>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image.png" class="" title="alt text">

<h2 id="关系数据库的规范化-1"><a href="#关系数据库的规范化-1" class="headerlink" title="关系数据库的规范化"></a>关系数据库的规范化</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1NF">1NF</a>：属性值都是不可分的<strong>原子值</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2NF">2NF</a>：在1NF基础上，消除了非主属性对候选键的<strong>部分函数依赖</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3NF">3NF</a>：在2NF基础上，消除了非主属性对候选键的<strong>传递函数依赖</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F">4NF</a>：消除了<strong>多值依赖</strong>的问题。</li>
</ul>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-2.png" class="" title="alt text">

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul>
<li>GRANT：授权</li>
<li>REVOKE：撤权</li>
</ul>
<h1 id="网络与信息安全基础知识"><a href="#网络与信息安全基础知识" class="headerlink" title="网络与信息安全基础知识"></a>网络与信息安全基础知识</h1><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><div style='overflow-x:auto;'>

<table>
<thead>
<tr>
<th>层次</th>
<th>名称</th>
<th>主要功能</th>
<th>主要设备及协议</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>应用层</td>
<td>实现具体的应用功能</td>
<td>POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>数据的格式与表达、加密、压缩</td>
<td>同应用层 ↑</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>建立、管理和终止会话</td>
<td>同应用层 ↑</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>端到端的连接（端口）</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>分组传输和路由选择（IP）</td>
<td>三层交换机、路由器、ARP、RARP、IP、ICMP、IGMP</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>传送以帧为单位的信息（MAC）</td>
<td>网桥、交换机、网卡、PPPT、L2TP、SLIP、PPP</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>二进制传输（01）</td>
<td>中继器、集线器</td>
</tr>
</tbody></table>
</div>

<h1 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a>未分类</h1><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>项目软件活动图中，关键路径指的是从开始到结束最长的一条路径</p>
<h2 id="沟通路径"><a href="#沟通路径" class="headerlink" title="沟通路径"></a>沟通路径</h2><p>$$<br>C&#x3D;n(n-1)&#x2F;2<br>$$</p>
<p>n：团队成员数量<br>C：沟通路径条数</p>
<h2 id="树的度、叶子节点数、边数"><a href="#树的度、叶子节点数、边数" class="headerlink" title="树的度、叶子节点数、边数"></a>树的度、叶子节点数、边数</h2><p>问：<br>对于一棵树，每个结点的孩子个数称为结点的度，结点度数的最大值成为树的度。某树T的度为4，其中有<code>5</code>个度为<code>4</code>的结点，<code>8</code>个度为<code>3</code>的结点，<code>6</code>个度为<code>2</code>的结点，<code>10</code>个度为<code>1</code>的结点，则T中的叶子结点个数为?</p>
<p>解：<br>设度为0的叶子结点数为$n_0$,度为1的结点数为$n_1$，度为2的结点数为$n_2$，度为3的结点数是$n_3$，度为4的结点数为$n_4$</p>
<p>$n_1&#x3D;10$</p>
<p>$n_2&#x3D;6$</p>
<p>$n_3&#x3D;8$</p>
<p>$n_4&#x3D;5$</p>
<p>这里有一个公式</p>
<p>$边的总数&#x3D;结点总数-1$</p>
<p>度数为n的节点会向下产生n条边，那么就有</p>
<p>$4n_4+3n_3+2n_2+n_1&#x3D;n_0+n_1+n_2+n_3+n_4-1$</p>
<p>$20+24+12+10&#x3D;n_0+29-1$</p>
<p>$n_0&#x3D;38$</p>
<p>因此叶子结点个数为38</p>
<h2 id="常见协议功能和默认端口"><a href="#常见协议功能和默认端口" class="headerlink" title="常见协议功能和默认端口"></a>常见协议功能和默认端口</h2><div style='overflow-x:auto;'>

<table>
<thead>
<tr>
<th>协议名</th>
<th>默认端口</th>
<th>功能</th>
<th>特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td>80</td>
<td>超文本传输协议，网页传输</td>
<td>不安全，结合SSL的HTTPS协议是安全的超文本传输协议，默认端口443</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
<td>远程协议</td>
<td>不安全，SSH是安全的远程协议</td>
</tr>
<tr>
<td>FTP</td>
<td>20数据 21控制</td>
<td>文件传输协议</td>
<td>不安全，结合SSL的SFTP是安全的文件传输协议。</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>邮件收取</td>
<td>附加多媒体数据时需采用MIME（MIME不安全，结合SSL的MIME&#x2F;S是安全的多媒体邮件协议）。使用WEB方式收发电子邮件时必须设置账号密码登录。</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
<td>邮件发送</td>
<td></td>
</tr>
<tr>
<td>DNS</td>
<td>53</td>
<td>域名解析协议，记录域名与IP的映射关系</td>
<td>本地客户端主机首查本机hosts文件 域名服务器首查本地缓存</td>
</tr>
<tr>
<td>DHCP</td>
<td>67</td>
<td>IP 地址自动分配</td>
<td>169.254.X.X 和 0.0.0.0 是无效地址</td>
</tr>
<tr>
<td>SNMP</td>
<td>161</td>
<td>简单网络管理协议</td>
<td>服务器仅发送消息给当前团体</td>
</tr>
<tr>
<td>ARP</td>
<td></td>
<td>地址解析协议，IP 地址转换为 MAC 地址</td>
<td>ARP Request 请求采用广播进行传送 ARP Response 响应采用单播进行传送</td>
</tr>
<tr>
<td>RARP</td>
<td></td>
<td>反向地址解析协议，MAC 地址转 IP 地址</td>
<td>无</td>
</tr>
<tr>
<td>ICMP</td>
<td></td>
<td>因特网控制协议</td>
<td>PING 命令来自该协议</td>
</tr>
<tr>
<td>IGMP</td>
<td></td>
<td>组播协议</td>
<td>无</td>
</tr>
</tbody></table>
</div>

<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><ol>
<li>Hash算法<ul>
<li>SHA</li>
</ul>
</li>
<li>对称加密算法<ul>
<li>DES</li>
<li>IDEA</li>
</ul>
</li>
<li>非对称加密算法<ul>
<li>RSA</li>
</ul>
</li>
</ol>
<h2 id="可靠度"><a href="#可靠度" class="headerlink" title="可靠度"></a>可靠度</h2><img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-1.png" class="" title="alt text">

<ul>
<li>串联的可靠度位每个部件相乘</li>
<li>并联的可靠度为$(1-(1-R)^n)$<br>其中$(1-R)$为单个组件的不可靠度，并联的总体不可靠度为<strong>单个组件的不可靠度的乘积</strong>$(1-R)^n$，因此总体的可靠度为$(1-(1-R)^n)$</li>
</ul>
<h2 id="数据库安全相关术语"><a href="#数据库安全相关术语" class="headerlink" title="数据库安全相关术语"></a>数据库安全相关术语</h2><ul>
<li><strong>拖库</strong>: 本是数据库领域的专用术语，指从数据库中导出数据。现指网站遭到入侵后，黑客窃取数据库的行为，即数据库信息泄露。</li>
<li><strong>撞库</strong>: 使用大量从一个网站获取的账号密码，尝试登录另一个网站。基于用户密码复用率较高的问题，利用泄露的密码尝试其他网站。</li>
<li><strong>洗库</strong>: 黑客入侵网站后获取大量用户数据，通过技术手段和黑色产业链将有价值的数据变现。</li>
<li><strong>社工库</strong>: 黑客将获取的各种数据库关联起来，对用户进行全方位画像。</li>
</ul>
<h2 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法"></a>软件测试方法</h2><ul>
<li><strong>语句覆盖</strong>：每个语句至少执行一次（进每个房间）。</li>
<li><strong>分支覆盖</strong>：每个条件的每个分支至少执行一次（开关每扇门）。</li>
<li><strong>判定覆盖</strong>：每个条件的每个布尔值（True&#x2F;False）至少执行一次（测试灯的开关）。</li>
<li><strong>路径覆盖</strong>：每条可能的路径至少执行一次（探索迷宫中的每条路径）。</li>
</ul>
<h2 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h2><h3 id="McCabe复杂度"><a href="#McCabe复杂度" class="headerlink" title="McCabe复杂度"></a>McCabe复杂度</h3><ul>
<li><strong>语句覆盖</strong>(Sstatement Coverage):也称为行覆盖，它关注的是程序中每一行代码是否至少被执行一次。这是最基本的测试爱盖标准，但往往只能发现简单的错误。</li>
<li><strong>判定覆盖</strong>(Decision Coverage):也称为分支覆盖，它要求程序中的每一个判定(例if-else语句)的每一种可能古果(真或假)都至少发生一次。这比语句夏盖更全面，但可能会逮漏一些错误。</li>
<li><strong>条件硬盖</strong>(Condtioncoverage):它要求程序中的每一个条件(例如语句中的条件)的每一种可能结果(真或假)都至少发生一次。虽然这比判定要盖更全面，但它仍然可能患漏一些错误，因为它不保证所有条件的组合都被测试到。</li>
<li><strong>路径硬盖</strong>(Patn Coverage):它要求测试瘦盖程序中所有可能的执行路径。这通常意味着测试需要遍历程序中所有可能的条件组合。路经覆善是这些法项中最全面的测试覆盖方法，因为它考虑了程序中所有可能的执行路径。</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-7.png" class="" title="alt text">

<p>语句覆盖：2<br>路径覆盖：4</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-8.png" class="" title="alt text">

<p>路径覆盖：6</p>
<h2 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h2><ul>
<li>流水线建立时间：第1条指令执行时间。</li>
<li>流水线周期：指令分段后，最长段时间。</li>
<li>流水线执行时间：流水线总+(指令条数- 1)*流水线周期。 </li>
<li>吞吐率&#x3D;指令条数&#x2F;流水线执行时间。</li>
<li>最大吞吐率&#x3D;流水线周期的倒数。</li>
</ul>
<h2 id="UML序列图"><a href="#UML序列图" class="headerlink" title="UML序列图"></a>UML序列图</h2><p>loop循环</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-9.png" class="" title="alt text">

<h2 id="文件系统索引"><a href="#文件系统索引" class="headerlink" title="文件系统索引"></a>文件系统索引</h2><img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-15.png" class="" title="alt text">

<p>第一问：地址直接访问和一级间接地址访问</p>
<p>第二问解答：</p>
<p>$1kb&#x2F;4b&#x3D;256$</p>
<p>直接索引地址：$5*(256^0)&#x3D;5$<br>一级间接地址索引：$2*(256^1)&#x3D;512$<br>二级间接地址索引：$1*(256^2)&#x3D;2^{16}$<br>$5+512+2^{16}&#x3D;66053$</p>
<p>第二问答案：66053</p>
<h2 id="页式存储管理系统"><a href="#页式存储管理系统" class="headerlink" title="页式存储管理系统"></a>页式存储管理系统</h2><img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-16.png" class="" title="alt text">

<p>0对应的是2<br>$2*4k&#x3D;8k&#x3D;8192$</p>
<img src="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/image-17.png" class="" title="alt text">

<p>逻辑地址8644对应的页号是2(8644&#x2F;4k,取2余452)<br>因此位于第2页452处，也就是第8块452处<br>$8*4k+452&#x3D;33220$<br>因此答案是33220</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%BD%AF%E8%80%83/">软考</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Kubernetes/kubernetes%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/"><span class="level-item">kubernetes部署服务</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#计算机系统知识"><span class="level-left"><span class="level-item">1</span><span class="level-item">计算机系统知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#CPU的组成"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">CPU的组成</span></span></a></li><li><a class="level is-mobile" href="#存储系统"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">存储系统</span></span></a></li><li><a class="level is-mobile" href="#校验码"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">校验码</span></span></a></li><li><a class="level is-mobile" href="#输入输出"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">输入输出</span></span></a></li></ul></li><li><a class="level is-mobile" href="#程序设计语言基础知识"><span class="level-left"><span class="level-item">2</span><span class="level-item">程序设计语言基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#后缀式"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">后缀式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据结构与数据运算"><span class="level-left"><span class="level-item">3</span><span class="level-item">数据结构与数据运算</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#树"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#树转二叉树"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">树转二叉树</span></span></a></li></ul></li><li><a class="level is-mobile" href="#图"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">图</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#最小生成树"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">最小生成树</span></span></a></li></ul></li><li><a class="level is-mobile" href="#查找"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">查找</span></span></a></li><li><a class="level is-mobile" href="#排序"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#软件工程基础知识"><span class="level-left"><span class="level-item">4</span><span class="level-item">软件工程基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#软件过程模型"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">软件过程模型</span></span></a></li><li><a class="level is-mobile" href="#软件的四个维护方面"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">软件的四个维护方面</span></span></a></li></ul></li><li><a class="level is-mobile" href="#结构化开发方法"><span class="level-left"><span class="level-item">5</span><span class="level-item">结构化开发方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#结构化分析方法"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">结构化分析方法</span></span></a></li><li><a class="level is-mobile" href="#结构化设计方法"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">结构化设计方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#面向对象技术"><span class="level-left"><span class="level-item">6</span><span class="level-item">面向对象技术</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#面向对象测试"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">面向对象测试</span></span></a></li><li><a class="level is-mobile" href="#UML的关系"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">UML的关系</span></span></a></li><li><a class="level is-mobile" href="#设计原则"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">设计原则</span></span></a></li><li><a class="level is-mobile" href="#设计模式"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">设计模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#创建型设计模式"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">创建型设计模式</span></span></a></li><li><a class="level is-mobile" href="#结构型设计模式"><span class="level-left"><span class="level-item">6.4.2</span><span class="level-item">结构型设计模式</span></span></a></li><li><a class="level is-mobile" href="#行为设计模式"><span class="level-left"><span class="level-item">6.4.3</span><span class="level-item">行为设计模式</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#算法设计与分析"><span class="level-left"><span class="level-item">7</span><span class="level-item">算法设计与分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分治法"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">分治法</span></span></a></li><li><a class="level is-mobile" href="#动态规划法"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">动态规划法</span></span></a></li><li><a class="level is-mobile" href="#贪心法"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">贪心法</span></span></a></li><li><a class="level is-mobile" href="#回溯法"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">回溯法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据库技术基础"><span class="level-left"><span class="level-item">8</span><span class="level-item">数据库技术基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关系数据库的规范化"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">关系数据库的规范化</span></span></a></li><li><a class="level is-mobile" href="#数据库操作"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">数据库操作</span></span></a></li><li><a class="level is-mobile" href="#关系数据库的规范化-1"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">关系数据库的规范化</span></span></a></li><li><a class="level is-mobile" href="#权限"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">权限</span></span></a></li></ul></li><li><a class="level is-mobile" href="#网络与信息安全基础知识"><span class="level-left"><span class="level-item">9</span><span class="level-item">网络与信息安全基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#网络体系结构"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">网络体系结构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#未分类"><span class="level-left"><span class="level-item">10</span><span class="level-item">未分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关键路径"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">关键路径</span></span></a></li><li><a class="level is-mobile" href="#沟通路径"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">沟通路径</span></span></a></li><li><a class="level is-mobile" href="#树的度、叶子节点数、边数"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">树的度、叶子节点数、边数</span></span></a></li><li><a class="level is-mobile" href="#常见协议功能和默认端口"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">常见协议功能和默认端口</span></span></a></li><li><a class="level is-mobile" href="#常见算法"><span class="level-left"><span class="level-item">10.5</span><span class="level-item">常见算法</span></span></a></li><li><a class="level is-mobile" href="#可靠度"><span class="level-left"><span class="level-item">10.6</span><span class="level-item">可靠度</span></span></a></li><li><a class="level is-mobile" href="#数据库安全相关术语"><span class="level-left"><span class="level-item">10.7</span><span class="level-item">数据库安全相关术语</span></span></a></li><li><a class="level is-mobile" href="#软件测试方法"><span class="level-left"><span class="level-item">10.8</span><span class="level-item">软件测试方法</span></span></a></li><li><a class="level is-mobile" href="#程序流程图"><span class="level-left"><span class="level-item">10.9</span><span class="level-item">程序流程图</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#McCabe复杂度"><span class="level-left"><span class="level-item">10.9.1</span><span class="level-item">McCabe复杂度</span></span></a></li><li><a class="level is-mobile" href="#测试"><span class="level-left"><span class="level-item">10.9.2</span><span class="level-item">测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#流水线技术"><span class="level-left"><span class="level-item">10.10</span><span class="level-item">流水线技术</span></span></a></li><li><a class="level is-mobile" href="#UML序列图"><span class="level-left"><span class="level-item">10.11</span><span class="level-item">UML序列图</span></span></a></li><li><a class="level is-mobile" href="#文件系统索引"><span class="level-left"><span class="level-item">10.12</span><span class="level-item">文件系统索引</span></span></a></li><li><a class="level is-mobile" href="#页式存储管理系统"><span class="level-left"><span class="level-item">10.13</span><span class="level-item">页式存储管理系统</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar/sasuke.jpg" alt="Shaway"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shaway</p><p class="is-size-6 is-block">但行好事，莫问前程</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>The junction of Teyvat and Demacia</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ShawayL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ShawayL"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"><img src="/images/cover/640%20(1).png" alt="软件设计师"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-04-18T06:14:00.000Z">2025-04-18</time></p><p class="title"><a href="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a></p><p class="categories"><a href="/categories/%E8%BD%AF%E8%80%83/">软考</a> / <a href="/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Kubernetes/kubernetes%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/"><img src="/images/cover/1050187.jpg" alt="kubernetes部署服务"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-12T01:48:00.000Z">2025-03-12</time></p><p class="title"><a href="/Kubernetes/kubernetes%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/">kubernetes部署服务</a></p><p class="categories"><a href="/categories/kubernetes/">kubernetes</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%8E%9F%E7%A0%81_%E5%8F%8D%E7%A0%81_%E8%A1%A5%E7%A0%81_%E7%A7%BB%E7%A0%81/"><img src="/images/cover/640%20(1).png" alt="原码、反码、补码、移码"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-07T06:14:00.000Z">2025-03-07</time></p><p class="title"><a href="/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%8E%9F%E7%A0%81_%E5%8F%8D%E7%A0%81_%E8%A1%A5%E7%A0%81_%E7%A7%BB%E7%A0%81/">原码、反码、补码、移码</a></p><p class="categories"><a href="/categories/%E8%BD%AF%E8%80%83/">软考</a> / <a href="/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/">软件设计师</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Docker/Liunx%E4%BD%BF%E7%94%A8Docker%E7%BC%96%E8%AF%91web%E9%A1%B9%E7%9B%AE/"><img src="/images/cover/qyccover0.jpg" alt="Liunx使用Docker编译web项目"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-02-25T03:20:56.000Z">2025-02-25</time></p><p class="title"><a href="/Docker/Liunx%E4%BD%BF%E7%94%A8Docker%E7%BC%96%E8%AF%91web%E9%A1%B9%E7%9B%AE/">Liunx使用Docker编译web项目</a></p><p class="categories"><a href="/categories/Docker/">Docker</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/C_C++/cpp%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Cstd-move/"><img src="/images/cover/1050187.jpg" alt="c++右值引用和std::move"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-06-30T02:39:49.000Z">2023-06-30</time></p><p class="title"><a href="/C_C++/cpp%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Cstd-move/">c++右值引用和std::move</a></p><p class="categories"><a href="/categories/C-C/">C/C++</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/ShawayL" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Shaway github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo/sasuke.png" alt="shaway" height="28"></a><p class="is-size-7"><span>&copy; 2025 shaway</span>  Powered by <a href="https://github.com/ShawayL" target="_blank" rel="noopener">Shaway</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ShawayL/ShawayL.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>